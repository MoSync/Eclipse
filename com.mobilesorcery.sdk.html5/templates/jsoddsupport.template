// Based on the AARDWOLF project: https://github.com/lexandera/Aardwolf
window.MoSyncDebugProtocol = new (function() {
    var serverHost = '%SERVER_HOST%';
    var serverPort = '%SERVER_PORT%';
    var project = '%PROJECT_NAME%';
    var serverUrl = 'http://' + serverHost + ':' + serverPort;
    var breakpoints = {};
    var breakpointDescs = {};
    var loadBreakpoints = {};
    var shouldBreak = function() { return false; };
    var asyncXHR = null;
    var lastFileId = -1;
    var lastLine = '';
    var lastEvalScopeFunc = null;
    
    var idToFile = [];
    var fileToId = {};
    
    var sessionId = null;
    var currentOID = 0;
    
    var disconnected = false;
    var terminating = false;
    var clientSuspend = 0;
    var step = false;
    
    var inUpdatePosition = false;

    this.assignOID = function(obj) {
        currentOID++;
        obj.____oid = currentOID;
    }
    
    function timestamp() {
        return new Date().getTime();
    }
    
    function listenToServer() {
        try {
            dropCommandConnection();
            
            if (disconnected || terminating) {
                return;
            }
            asyncXHR = new XMLHttpRequest();
            asyncXHR.onreadystatechange = function () {
                if (asyncXHR.readyState == 4) {
                    if (asyncXHR.responseText) {
                        var cmd = safeJSONParse(asyncXHR.responseText);
                            
                        if (cmd && cmd.command == 'eval') {
                            doEval(function(____fn) { return eval(____fn); }, cmd);
                        }
                        else {
                            processCommand(cmd);
                        }
                        
                        setTimeout(listenToServer, 0);
                    }
                }
            };
            asyncXHR.open('GET', serverUrl + '/mobile/incoming/' + timestamp(), true);
            asyncXHR.send(null);
        } catch (ex) {
            disconnect(ex);
        }
    }
    
    function disconnect(ex) {
        if (!disconnected) {
            disconnected = true;
            alert('Disconnected from debug session. To debug, you need to restart.\nReason:' + ex.toString());
        }
    }
    
    function dropCommandConnection() {
        if (asyncXHR) {
            asyncXHR.abort();
        }
        asyncXHR = null;
    }
    
    function sendToServer(path, payload) {
        try {
            var req = new XMLHttpRequest();
            req.open('POST', serverUrl + '/mobile' + path + "/" + timestamp(), false);
            req.setRequestHeader('Content-Type', 'application/json');
            if (sessionId != null) {
                payload.sessionId = sessionId;
            }
            var json = JSON.stringify(payload)
            req.send(json);
            return safeJSONParse(req.responseText);
        } catch (ex) {
            disconnect(ex);
        }
    }
    
    function replaceConsole() {
        if (!window.console) {
            window.console = {};
        }
        
        ['info', 'log', 'warn', 'error'].forEach(function(f) {
            var oldFunc = window.console[f];
            
            window.console[f] = function() {
                var args = Array.prototype.slice.call(arguments);
                /* Write to local console before writing to the potentially slow remote console.
                   Make sure that the original function actually exists, otherwise this will
                   case an error on WindowsPhone where the console object is not available. */
                oldFunc && oldFunc.apply(window.console, args);
                sendToServer('/console', { 
                    command: 'print-message',
                    type: f.toUpperCase(),
                    message: args.toString()
                });
            };
        });
    }
    
    function suspendOnNext() {
        step = true;
        shouldBreak = function() { return true; };            
    }
    
    function processCommand(cmd) {
        switch (cmd.command) {
            case 'set-breakpoints':
            case 'clear-breakpoints':
                cmd.data.forEach(function(bp) {
                    var file = bp.file;
                    var line = bp.line;
                    var condition = bp.condition;
                    var conditionSuspend = bp.conditionSuspend;
                    var hitcount = bp.hitcount;
                    var fileId = fileToId[file];
                    var set = (cmd.command == 'set-breakpoints');
                    if (line >= 0 && fileId) {
                        if (!breakpoints[fileId]) {
                            breakpoints[fileId] = {};
                        }
                        breakpoints[fileId][line] = set;
                        if (!breakpointDescs[fileId]) {
                            breakpointDescs[fileId] = {};
                        }
                        var breakpointDesc = {};
                        if (condition) {
                        	breakpointDesc.condition = condition;
                        }
                        if (conditionSuspend) {
                            breakpointDesc.conditionSuspend = conditionSuspend;
                        }
                        if (hitcount) {
                            breakpointDesc.hitcount = hitcount - 1;
                        }
                        breakpointDescs[fileId][line] = breakpointDesc;
                    } else {
                        // Script load.
                        if (fileId == '*') {
                            // All files
                            for (var fileId in idToFile) {
                                loadBreakpoints[fileId] = set;
                            }
                        } else {
                            loadBreakpoints[fileId] = set;
                        }
                    }
                });
                if (cmd.suspend) {
                    suspendOnNext();
                }
                return true;
            
            case 'breakpoint-continue':
                shouldBreak = function() { return false; };
                return false;
            
            case 'suspend':
                clientSuspend = cmd.id;
            case 'break-on-next':
            case 'breakpoint-step':
            case 'breakpoint-step-in':
                suspendOnNext();
                return false;
                
            case 'breakpoint-step-out':
                step = true;
                shouldBreak = (function(oldDepth) {
                    return function(depth) {
                        return depth < oldDepth;
                    };
                })(stackDepth);
                return false;
                
            case 'breakpoint-step-over':
                step = true;
                shouldBreak = (function(oldDepth) {
                    return function(depth) {
                        return depth <= oldDepth;
                    };
                })(stackDepth);
                return false;
                
            case 'terminate':
                terminating = true;
                step = false;
                shouldBreak = function() { return false; };
                // Try to kill it -- this obviously requires wormhole.
                mosync.bridge.send(["close"]);
                return false;
                
            case 'disconnect':
                step = false;
                shouldBreak = function() { return false; };
                disconnect("Disconnected by debugger");
                return false;
        }
    }
    
    function doEval(evalScopeFunc, cmd) {
        var evalResult;
        try {
            if (cmd.stackDepth) {
                var fn = evalScopes[cmd.stackDepth];
                evalResult = fn(cmd.data);
            } else {
                evalResult = evalScopeFunc(cmd.data);
            }
        } catch (ex) {
            evalResult = 'ERROR: ' + ex.toString();
        }  
        sendToServer('/console', {
            command: 'print-eval-result',
            result: evalResult,
            id: cmd.id
        });
    }
    
    function getStack() {
        var callstack = [];
        var currentFunction = arguments.callee;
        while (currentFunction = currentFunction.caller) {
            var fname = currentFunction.name || '<anonymous>';
            callstack.push(fname);
        }
        return callstack;
    }
    
    function internalJSONParse(JSONDocument) {
        // This function is here because wormhole.js
        // overrides the default JSON.parse and we
        // later instrument that method. So we'd
        // get a quasi-infinite loop when debugging
        // wormhole.js functions.
        var parsedObject = eval('(' + JSONDocument + ')');
        return parsedObject;
    }
    
    function safeJSONParse(str) {
        try {
            return internalJSONParse(str);
        } catch (ex) {
            return null;
        }
    }
    
    this.init = function() {
        %INIT_FILE_IDS%
        replaceConsole();
        var location = window ? window.document.location.href : "<unknown>";
        var cmd = sendToServer('/init', {
            command: 'mobile-connected',
            project: project,
            location: location
        });
        
        if (cmd) {
            sessionId = cmd.sessionId;
            processCommand(cmd);
        }

        listenToServer();
    };
    
    this.loadScript = function(fileId, segment) {
        var cmd = sendToServer('/load-script', {
            file: fileId,
            segment: segment
        });
        if (cmd) {
            processCommand(cmd);
        }
    }
    
    this.updatePosition = function(fileId, line, isDebuggerStatement, evalScopeFunc) {
        if (inUpdatePosition || terminating || disconnected) {
            return;
        }
        inUpdatePosition = true;
        
        /* Webkit's exceptions don't contain any useful file and line data,
           so we keep track of this manually for exception reporting purposes. */
        lastFileId = fileId;
        lastLine = line;
        lastEvalScopeFunc = evalScopeFunc;
                
        while (true) {
            var isBreakpoint = (breakpoints[fileId] && breakpoints[fileId][line]) || /* explicit breakpoint? */
                               loadBreakpoints[fileId] ||
                               isDebuggerStatement ||                            /* debugger; statement? */
                               shouldBreak(stackDepth);                          /* step (in|over|out) or break-on-next? */
            
            if (isBreakpoint && breakpointDescs[fileId] && breakpointDescs[fileId][line]) {
                var breakpointDesc = breakpointDescs[fileId][line];
                var condition = breakpointDesc.condition;
                var hitcount = breakpointDesc.hitcount;
                if (condition) {
                    var conditionSuspend = breakpointDesc.conditionSuspend;
                    var evaluatedCondition = evalScopeFunc(condition);
                    if ("change" == conditionSuspend) {
                        isBreakpoint = (evaluatedCondition != breakpointDesc.lastEvaluation);
                    } else {
                        isBreakpoint = evaluatedCondition;
                    }
                }
                if (isBreakpoint && hitcount) {
                    breakpointDesc.hitcount--;
                    isBreakpoint = false;
                }
            }

            if (!isBreakpoint) {
                inUpdatePosition = false;
                return;
            }
        
            dropCommandConnection();
            
            var file = idToFile[fileId];
            var type = 'line';
            if (loadBreakpoints[fileId]) {
                type = 'load';
                loadBreakpoints[fileId] = false;
            } else if (isDebuggerStatement) {
                type = 'debugger';
            }
            
            var cmd = sendToServer('/breakpoint', {
                command: 'report-breakpoint',
                type: type,
                file: file,
                line: line,
                stack: stack,
                step: step,
                suspended: (clientSuspend > 0),
                id: clientSuspend
            });
            clientSuspend = 0;
            suspendOnLoad = false;
            
            step = false;
                        
            if (!cmd) {
                listenToServer();
                inUpdatePosition = false;       
                return;
            }                
                
            if (cmd.command == 'eval') {
                doEval(evalScopeFunc, cmd);
            }
            else {
                var isInternalCommand = processCommand(cmd);
                if (!isInternalCommand) {
                    listenToServer();
                    inUpdatePosition = false;       
                    return;
                }
            }
        }
        
    };
    
    this.reportException = function(e) {
        var lastFile = idToFile[lastFileId];
        sendToServer('/breakpoint', {
            command: 'report-breakpoint',
            type: 'exception',
            message: e.toString(),
            file: lastFile,
            line: lastLine,
            stack: stack
        });
    }
    
    var stack = [];
    var evalScopes = [];
    var stackDepth = 0;
    
    this.pushStack = function(functionName, file, line) {
        stack.push([functionName, file, line, lastLine]);
        evalScopes.push(lastEvalScopeFunc);
        ++stackDepth;
    };
    
    this.popStack = function() {
        stack.pop();
        evalScopes.pop();
        --stackDepth;
    };
    
})();

window.MoSyncDebugProtocol.init();